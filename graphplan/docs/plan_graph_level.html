<html>
  <head>
  <title>plan_graph_level.py</title>
  </head>
  <body>
  <h3>plan_graph_level.py (<a href="../plan_graph_level.py">original</a>)</h3>
  <hr>
  <pre>
<span style="color: blue; font-weight: bold">from </span>action_layer <span style="color: blue; font-weight: bold">import </span>ActionLayer
<span style="color: blue; font-weight: bold">from </span>util <span style="color: blue; font-weight: bold">import </span>Pair
<span style="color: blue; font-weight: bold">from </span>proposition <span style="color: blue; font-weight: bold">import </span>Proposition
<span style="color: blue; font-weight: bold">from </span>proposition_layer <span style="color: blue; font-weight: bold">import </span>PropositionLayer


<span style="color: blue; font-weight: bold">class </span>PlanGraphLevel<span style="font-weight: bold">(</span>object<span style="font-weight: bold">):
    </span><span style="color: darkred">"""
    A class for representing a level in the plan graph.
    For each level i, the PlanGraphLevel consists of the actionLayer and propositionLayer at this level in this order!
    """
    </span>independent_actions <span style="font-weight: bold">= </span>set<span style="font-weight: bold">()  </span><span style="color: green; font-style: italic"># updated to the independent_actions of the problem (graph_plan.py line 32)
    </span>actions <span style="font-weight: bold">= []  </span><span style="color: green; font-style: italic"># updated to the actions of the problem (graph_plan.py line 33 and planning_problem.py line 36)
    </span>props <span style="font-weight: bold">= []  </span><span style="color: green; font-style: italic"># updated to the propositions of the problem (graph_plan.py line 34 and planning_problem.py line 36)

    </span>@staticmethod
    <span style="color: blue; font-weight: bold">def </span>set_independent_actions<span style="font-weight: bold">(</span>independent_actions<span style="font-weight: bold">):
        </span>PlanGraphLevel<span style="font-weight: bold">.</span>independent_actions <span style="font-weight: bold">= </span>independent_actions

    @staticmethod
    <span style="color: blue; font-weight: bold">def </span>set_actions<span style="font-weight: bold">(</span>actions<span style="font-weight: bold">):
        </span>PlanGraphLevel<span style="font-weight: bold">.</span>actions <span style="font-weight: bold">= </span>actions

    @staticmethod
    <span style="color: blue; font-weight: bold">def </span>set_props<span style="font-weight: bold">(</span>props<span style="font-weight: bold">):
        </span>PlanGraphLevel<span style="font-weight: bold">.</span>props <span style="font-weight: bold">= </span>props

    <span style="color: blue; font-weight: bold">def </span>__init__<span style="font-weight: bold">(</span><span style="color: blue">self</span><span style="font-weight: bold">):
        </span><span style="color: darkred">"""
        Constructor
        """
        </span><span style="color: blue">self</span><span style="font-weight: bold">.</span>action_layer <span style="font-weight: bold">= </span>ActionLayer<span style="font-weight: bold">()  </span><span style="color: green; font-style: italic"># see action_layer.py
        </span><span style="color: blue">self</span><span style="font-weight: bold">.</span>proposition_layer <span style="font-weight: bold">= </span>PropositionLayer<span style="font-weight: bold">()  </span><span style="color: green; font-style: italic"># see proposition_layer.py

    </span><span style="color: blue; font-weight: bold">def </span>get_proposition_layer<span style="font-weight: bold">(</span><span style="color: blue">self</span><span style="font-weight: bold">):  </span><span style="color: green; font-style: italic"># returns the proposition layer
        </span><span style="color: blue; font-weight: bold">return </span><span style="color: blue">self</span><span style="font-weight: bold">.</span>proposition_layer

    <span style="color: blue; font-weight: bold">def </span>set_proposition_layer<span style="font-weight: bold">(</span><span style="color: blue">self</span><span style="font-weight: bold">, </span>prop_layer<span style="font-weight: bold">):  </span><span style="color: green; font-style: italic"># sets the proposition layer
        </span><span style="color: blue">self</span><span style="font-weight: bold">.</span>proposition_layer <span style="font-weight: bold">= </span>prop_layer

    <span style="color: blue; font-weight: bold">def </span>get_action_layer<span style="font-weight: bold">(</span><span style="color: blue">self</span><span style="font-weight: bold">):  </span><span style="color: green; font-style: italic"># returns the action layer
        </span><span style="color: blue; font-weight: bold">return </span><span style="color: blue">self</span><span style="font-weight: bold">.</span>action_layer

    <span style="color: blue; font-weight: bold">def </span>set_action_layer<span style="font-weight: bold">(</span><span style="color: blue">self</span><span style="font-weight: bold">, </span>action_layer<span style="font-weight: bold">):  </span><span style="color: green; font-style: italic"># sets the action layer
        </span><span style="color: blue">self</span><span style="font-weight: bold">.</span>action_layer <span style="font-weight: bold">= </span>action_layer

    <span style="color: blue; font-weight: bold">def </span>update_action_layer<span style="font-weight: bold">(</span><span style="color: blue">self</span><span style="font-weight: bold">, </span>previous_proposition_layer<span style="font-weight: bold">):
        </span><span style="color: darkred">"""
        Updates the action layer given the previous proposition layer (see proposition_layer.py)
        You should add an action to the layer if its preconditions are in the previous propositions layer,
        and the preconditions are not pairwise mutex.
        all_actions is the set of all the action (include noOp) in the domain
        You might want to use those functions:
        previous_proposition_layer.is_mutex(prop1, prop2) returns true
        if prop1 and prop2 are mutex at the previous propositions layer
        previous_proposition_layer.all_preconds_in_layer(action) returns true
        if all the preconditions of action are in the previous propositions layer
        self.actionLayer.addAction(action) adds action to the current action layer
        """
        </span>all_actions <span style="font-weight: bold">= </span>PlanGraphLevel<span style="font-weight: bold">.</span>actions
        <span style="color: red">"*** YOUR CODE HERE ***"

    </span><span style="color: blue; font-weight: bold">def </span>update_mutex_actions<span style="font-weight: bold">(</span><span style="color: blue">self</span><span style="font-weight: bold">, </span>previous_layer_mutex_proposition<span style="font-weight: bold">):
        </span><span style="color: darkred">"""
        Updates the mutex set in self.action_layer,
        given the mutex proposition from the previous layer.
        current_layer_actions are the actions in the current action layer
        You might want to use this function:
        self.actionLayer.add_mutex_actions(action1, action2)
        adds the pair (action1, action2) to the mutex set in the current action layer
        Note that an action is *not* mutex with itself
        """
        </span>current_layer_actions <span style="font-weight: bold">= </span><span style="color: blue">self</span><span style="font-weight: bold">.</span>action_layer<span style="font-weight: bold">.</span>get_actions<span style="font-weight: bold">()
        </span><span style="color: red">"*** YOUR CODE HERE ***"

    </span><span style="color: blue; font-weight: bold">def </span>update_proposition_layer<span style="font-weight: bold">(</span><span style="color: blue">self</span><span style="font-weight: bold">):
        </span><span style="color: darkred">"""
        Updates the propositions in the current proposition layer,
        given the current action layer.
        don't forget to update the producers list!
        Note that same proposition in different layers might have different producers lists,
        hence you should create two different instances.
        current_layer_actions is the set of all the actions in the current layer.
        You might want to use those functions:
        dict() creates a new dictionary that might help to keep track on the propositions that you've
               already added to the layer
        self.proposition_layer.add_proposition(prop) adds the proposition prop to the current layer

        """
        </span>current_layer_actions <span style="font-weight: bold">= </span><span style="color: blue">self</span><span style="font-weight: bold">.</span>action_layer<span style="font-weight: bold">.</span>get_actions<span style="font-weight: bold">()
        </span><span style="color: red">"*** YOUR CODE HERE ***"

    </span><span style="color: blue; font-weight: bold">def </span>update_mutex_proposition<span style="font-weight: bold">(</span><span style="color: blue">self</span><span style="font-weight: bold">):
        </span><span style="color: darkred">"""
        updates the mutex propositions in the current proposition layer
        You might want to use those functions:
        mutex_propositions(prop1, prop2, current_layer_mutex_actions) returns true
        if prop1 and prop2 are mutex in the current layer
        self.proposition_layer.add_mutex_prop(prop1, prop2) adds the pair (prop1, prop2)
        to the mutex set of the current layer
        """
        </span>current_layer_propositions <span style="font-weight: bold">= </span><span style="color: blue">self</span><span style="font-weight: bold">.</span>proposition_layer<span style="font-weight: bold">.</span>get_propositions<span style="font-weight: bold">()
        </span>current_layer_mutex_actions <span style="font-weight: bold">= </span><span style="color: blue">self</span><span style="font-weight: bold">.</span>action_layer<span style="font-weight: bold">.</span>get_mutex_actions<span style="font-weight: bold">()
        </span><span style="color: red">"*** YOUR CODE HERE ***"

    </span><span style="color: blue; font-weight: bold">def </span>expand<span style="font-weight: bold">(</span><span style="color: blue">self</span><span style="font-weight: bold">, </span>previous_layer<span style="font-weight: bold">):
        </span><span style="color: darkred">"""
        Your algorithm should work as follows:
        First, given the propositions and the list of mutex propositions from the previous layer,
        set the actions in the action layer.
        Then, set the mutex action in the action layer.
        Finally, given all the actions in the current layer,
        set the propositions and their mutex relations in the proposition layer.
        """
        </span>previous_proposition_layer <span style="font-weight: bold">= </span>previous_layer<span style="font-weight: bold">.</span>get_proposition_layer<span style="font-weight: bold">()
        </span>previous_layer_mutex_proposition <span style="font-weight: bold">= </span>previous_proposition_layer<span style="font-weight: bold">.</span>get_mutex_props<span style="font-weight: bold">()

        </span><span style="color: red">"*** YOUR CODE HERE ***"

    </span><span style="color: blue; font-weight: bold">def </span>expand_without_mutex<span style="font-weight: bold">(</span><span style="color: blue">self</span><span style="font-weight: bold">, </span>previous_layer<span style="font-weight: bold">):
        </span><span style="color: darkred">"""
        Questions 11 and 12
        You don't have to use this function
        """
        </span>previous_layer_proposition <span style="font-weight: bold">= </span>previous_layer<span style="font-weight: bold">.</span>get_proposition_layer<span style="font-weight: bold">()
        </span><span style="color: red">"*** YOUR CODE HERE ***"


</span><span style="color: blue; font-weight: bold">def </span>mutex_actions<span style="font-weight: bold">(</span>a1<span style="font-weight: bold">, </span>a2<span style="font-weight: bold">, </span>mutex_props<span style="font-weight: bold">):
    </span><span style="color: darkred">"""
    This function returns true if a1 and a2 are mutex actions.
    We first check whether a1 and a2 are in PlanGraphLevel.independent_actions,
    this is the list of all the independent pair of actions (according to your implementation in question 1).
    If not, we check whether a1 and a2 have competing needs
    """
    </span><span style="color: blue; font-weight: bold">if </span>Pair<span style="font-weight: bold">(</span>a1<span style="font-weight: bold">, </span>a2<span style="font-weight: bold">) </span><span style="color: blue; font-weight: bold">not in </span>PlanGraphLevel<span style="font-weight: bold">.</span>independent_actions<span style="font-weight: bold">:
        </span><span style="color: blue; font-weight: bold">return True
    return </span>have_competing_needs<span style="font-weight: bold">(</span>a1<span style="font-weight: bold">, </span>a2<span style="font-weight: bold">, </span>mutex_props<span style="font-weight: bold">)


</span><span style="color: blue; font-weight: bold">def </span>have_competing_needs<span style="font-weight: bold">(</span>a1<span style="font-weight: bold">, </span>a2<span style="font-weight: bold">, </span>mutex_props<span style="font-weight: bold">):
    </span><span style="color: darkred">"""
    Complete code for deciding whether actions a1 and a2 have competing needs,
    given the mutex proposition from previous level (list of pairs of propositions).
    Hint: for propositions p  and q, the command  "Pair(p, q) in mutex_props"
          returns true if p and q are mutex in the previous level
    """
    </span><span style="color: red">"*** YOUR CODE HERE ***"


</span><span style="color: blue; font-weight: bold">def </span>mutex_propositions<span style="font-weight: bold">(</span>prop1<span style="font-weight: bold">, </span>prop2<span style="font-weight: bold">, </span>mutex_actions_list<span style="font-weight: bold">):
    </span><span style="color: darkred">"""
    complete code for deciding whether two propositions are mutex,
    given the mutex action from the current level (set of pairs of actions).
    Your update_mutex_proposition function should call this function
    You might want to use this function:
    prop1.get_producers() returns the set of all the possible actions in the layer that have prop1 on their add list
    """
    </span><span style="color: red">"*** YOUR CODE HERE ***"
</span>
  </pre>
  </body>
  </html>
  